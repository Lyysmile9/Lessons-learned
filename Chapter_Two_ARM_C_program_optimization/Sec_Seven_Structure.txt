结构体的问题
	地址对齐问题
	数据存取效率问题

结构体地址边界对齐
struct{
	char a;
	int b;
	char c;
	short d;
}
/*假设32位处理器*/
	————————————————————————————————————————
高地址 |   pad    |   pad    |   pad   |    a   | 低地址
	————————————————————————————————————————
       | b[31,24] | b[23,16] | b[15,8] | b[7,0] |
        ————————————————————————————————————————
       | d[15,8]  | d[7,0]   |   pad   |    c   |
        ————————————————————————————————————————
/*每一行32位，4个字节，每个字节表示8个二进制位*/
/*整型变量必须占据完整一行，所以a剩余空间不可使用*/
/*短整型变量必须放到内存的偶数地址*/

重新定义
struct{
	char a;
	char c;
	short d;
	int b;
}

	————————————————————————————————————————
高地址 | d[15,8]  | d[7,0]   |    c    |    a   | 低地址
	————————————————————————————————————————
       | b[31,24] | b[23,16] | b[15,8] | b[7,0] |
        ————————————————————————————————————————

结论
	把所有8位元素安排在结构体的前面
	依次安排16位、32位元素
	把数组和大元素安排到后面
	对于一条指令，如果结构体太大而不能访问所有元素，
	可以把元素组织成一个子结构，编译器可以单独维持其指针

使用关键字__packed
__packed struct{
	char a;
	int b;
	char c;
	short d;
}

	————————————————————————————————————————
高地址 | b[23,16] | b[15,8]  | b[7,0]  |    a   | 低地址
	————————————————————————————————————————
       | d[15,8]  | d[7,0]   |    c    |b[31,24]|
        ————————————————————————————————————————
/*armcc支持使用关键字__packed,可以不必插入填充位。*/
/*适用于空间非常紧张的场合，运行效率非常低。*/

例:__packed的影响
int readint(__packed int *data)
{
	return *data;
}

				     data
				       |
				       V
	————————————————————————————————————————
高地址 | b[23,16] | b[15,8]  | b[7,0]  |    a   | 低地址
	————————————————————————————————————————
       | d[15,8]  | d[7,0]   |    c    |b[31,24]|
        ————————————————————————————————————————
/*因为int *data 用__packed修饰，该指针不再需要地址对齐，假设指向如上图位置*/
/*需要将指针指向的位置的整型数据取出，分如下三步：*/
	/*首先取出第一行，然后做右移8位的操作，空出来的位用0填充*/
	/*把第二行取出，然后做左移24位的操作*，空出来的位用0填充/
	/*最后把上述两步的结果做或操作，即可得到完整的整型数据*/
/*还有其他的可能性*/

结论
	__packed关键字严重影响效率，大小端不一致也有同样问题，采用char*可以避免，因位字符型指针在任何位置都是天然对齐的。
