处理功能键
	功能键的问题在于，用户界面有很多“控件”元素，在不同“控件”上按下功能键，实际执行的功能不同。
	 ———————	 ———————	 ———————	 ———————
	| 菜单1 |	| 菜单2 |	| 菜单3 |	| 菜单4 |
	 ———————	 ———————	 ———————	 ———————
	    |
	    |
	    |
	    V
	 ——————		 ——————————	 ———————	 ————————
	|  OK  |	|  CANCEL  |	|  SET  |	|  QUIT  |
	 ——————		 ——————————	 ———————	 ————————

WIN32机制
	WIN32编程中用到“窗口”概念，当消息(message)被发送给不同窗口的时候，该窗口的消息处理函数(是一个callback函数)最终被调用，由它来判断该消息应该进一步发给窗口中的哪一个元素，进而调用该元素的处理函数。
	通过这种方式，WIN32有效的组织了不同窗口，并处理不同窗口情况下的消息。

嵌入式系统采取的策略
	将不同的画面类比为WIN32中不同的窗口，将窗口中的各种元素(菜单、按钮等)包含在窗口之中；
	给各个画面提供一个功能键“消息”处理函数，该函数接收按键信息为参数；
	在各画面的功能键“消息”处理函数中，判断按键类型和当前焦点元素，并调用对应元素的按键处理函数。

/*将窗口元素、消息处理函数封装在窗口中*/

struct windows
{
	BYTE currentFocus;
	ELEMENT element[ELEMENT_NUM];
	void(*messageFun)(BYTE keyValue)；
	...
};

/*消息处理函数*/
void messageFunction(BYTE keyValue)
{
	BYTE i = 0;
	/*获得焦点元素*/
	while((element[i].ID != currentFocus && (i < ELEMENT_NUM)))
		i++;
	if(i < ELEMENT_NUM)				//消息映射
	{
		switch(keyValue)
		{
			case OK:
			element[i].OnOk();
			break;
			...
		}
	}
}
