汉字处理：嵌入式系统汉字库的特点
	嵌入式系统中经常使用的并非是完整的汉字库，往往只是需要提供数量有限的汉字供必要的显示功能。
	例如，一个微波炉的LCD上没有必要提供显示“电子邮件”的功能；一个提供汉字显示功能的空调的LCD上不需要显示一条“短消息”，诸如此类。
	但是一部手机则通常需要包括较完整的汉字库。

完整字库
	如果包括的汉字库较完整，那么，由内码（汉字在计算机内部的表现形式）计算出汉字字模在库中的偏移是十分简单的：汉字是按照区位的顺序排列的，前一个字节为该汉字的区号，后一个字节为该汉字的位号。
	每一个区记录94个汉字，位号则为该字在区中的位置。
	因此，汉字在汉字库中的具体位置计算公式为：
	94*（区号-1）+位号-1
	然后乘上一个汉字字模占用的字节数即可，以16*16点阵字库为例，即：
	（94*（区号-1）+（位号-1））*32
	汉字库中从该位置起的32字节信息记录了该字的字模信息。

仅使用少量汉字

#define EX_FONT_WORD(value) (value)
#define EX_FONT_UNICODE_VAL(value) (value)

typedef struct _wide_unicode_font 16x16
{
	unsigned char word[3];
	int value;		//内码
	unsigned char data[32];	//字模点阵
}Unicode;

#define CHINESE_CHAR_NUM	4 //汉字数量

Unicode chinese[CHINESE_CHAR_NUM] =
{
	{
		EX_FONT_WORD("业")，
		EX_FONT_UNICODE_VAL(0x4e1a),				//业的内码
		{							
		  0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x04, 0x44,	//业的字模
		  0x44, 0x46, 0x24, 0x4c, 0x24, 0x28, 0x14, 0x50,
		  0x1c, 0x50, 0x14, 0x60, 0x04, 0x40, 0x04, 0x40,
		  0x04, 0x44, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00
		}
	},
	{ ...	}, { ...   }，{ ...   }
}

	要显示特定汉字的时候，只需要从数组中查找内码与要求汉字内码相同的即可获得字模。
	如果前面的汉字在数组中以内码大小顺序排序，那么可以以二分查找法更高效的查找到汉字的字模。
	这是一种很有效的组织小汉字库的方法，它可以保证程序有很好的结构。
