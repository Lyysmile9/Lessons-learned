嵌入式软件架构
	模块划分
	任务模式
	中断服务程序

模块划分
	模块划分的“划”是规划的意思，意指怎样合理的将一个很大的软件划分为一系列功能独立的部分，合作完成系统的需求。
	C语言作为一种结构化的程序设计语言，在模块划分上主要依据功能。

模块划分的方法
	模块即是一个.c文件和一个.h文件的结合，头文件（.h）中是对于该模块接口的声明
	某模块提供给其他模块调用的外部函数及数据需在.h文件中冠以extern关键字声明
	仅在模块内部使用的函数和全局变量需在.c文件开头冠以static关键字声明
	永远不要再.h文件中定义变量！定义变量和声明变量的区别在于定义会产生内存分配的操作。

一个不好的例子
	试图在三个模块中共享一个变量a
	/*module1.h*/
	int a =5;		//在模块1的.h文件中定义int a

	/*module1.c*/
	#include "module1.h"	//在模块1中包含模块1的.h文件
	
	/*module2.c*/
	#include "module1.h"	//在模块2中包含模块1的.h文件
	
	/*module3.c*/
	#include "module1.h"	//在模块3中包含模块1的.h文件
/*有的编译器会报错，提示变量命名冲突，而有的编译器会将变量a作为静态变量使用、只在自己的模块中使用而无法在其他模块中使用，总之无法达到在多个模块中共享一个变量的目的*/

一个好的例子
	/*module1.h*/
	extern int a;		//在模块1的.h文件中声明int a

	/*module1.c*/
	int a = 5;		//在模块1的.c文件中定义int a
	
	/*module2.c*/
	#include "module1.h"	//在模块2中包含模块1的.h文件

	/*module3.c*/
	#include "module1.h"	//在模块3中包含模块1的.h文件

两种类型模块：一个嵌入式系统通常包括两类模块
	硬件驱动模块，一种特定硬件对应一个模块；
	软件功能模块，其模块的划分应满足低耦合、高内聚的要求
		低耦合：不同模块之间的联系尽可能的少
		高内聚：一个模块中的功能应该单一

任务模式
	单任务：微观串行、宏观串行
	多任务：微观串行、宏观并行

单任务程序典型架构
	从CPU复位时的指定地址开始执行（一般为0地址处、会安排一个绝对跳转指令）
	跳转至汇编代码startup处执行，部分初始化操作
	跳转至用户主程序main执行，在main中完成：
		初始化部分硬件设备
		初始化各软件模块
		进入死循环（无限循环），调用各模块的处理函数

无限循环较好的方式：
	while(1)
	{
	}

中断服务程序
	中断是嵌入式系统重要的组成部分，但是在标准c中不包含中断。
	许多编译开发商在标准c上增加了对中断的支持，提供新的关键字用于标识中断服务程序（ISR），类似于__interrupt，例如C51
	当一个函数被定义为ISR的时候，编译器会自动为该函数增加中断服务程序所需要的中断现场入栈和出栈代码

中断程序的特点
	不能返回值（中断随机发生、也没有调用者，所以返回值不知道返回给哪个函数）
	不能向ISR传递参数（同上）
	ISR应该尽可能短小精悍（处理器在进入中断之前大多会关中断、于是不会再响应外界中断、如果中断程序太大会导致在中断时间太长，会影响整个系统的实时性）
	printf(char * lpFormatString...)函数会带来性能问题，不能在ISR中采用

中断服务程序模型
	在项目的开发中，设计一个队列，在中断服务程序中，只是将中断类型添加到该队列中，在主程序的无限循环中不断扫描中断队列是否有中断，有则取出队列中的第一个中断类型，进行相应处理

typedef struct tagIntQueue			//存放中断的队列
{
	int intType;				//中断类型
	struct tagIntQueue *next;
}IntQueue;

IntQueue *lpIntQueueHead;

__interrupt ISRexample()
{
	int intType;
	intType = GetSystemType();		//得到中断类型
	QueueAddTail(lpIntQueueHead, intType);	//在队列尾加入新的中断
}

主程序模型

while(1)
{
	if(!IsIntQueueEmpty())
	{
		intType = GetFirstInt();
		switch(intType)
		{
			case xxx:
			...		//中断处理代码
			break;
			case xxx:
			...
			break;
			...
		}
	}
}
